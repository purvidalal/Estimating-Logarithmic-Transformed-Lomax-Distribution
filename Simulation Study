import numpy as np
import pandas as pd
from scipy.optimize import minimize


def ltlo_pdf(x, phi, sigma, tau):
    x = np.asarray(x, float)
    pdf = np.zeros_like(x)

    valid = x > 0
    if not np.any(valid):
        return pdf

    xv = x[valid]

    # stable ratio in [0,1]
    ratio = (tau / (tau + xv)) ** sigma

    term = 1 - (1 - phi) * ratio
    term = np.maximum(term, 1e-12)

    num = (phi - 1) * sigma * ratio / (tau + xv)
    denom = np.log(phi) * term

    val = num / denom
    val[~np.isfinite(val)] = 0
    val[val < 0] = 0

    pdf[valid] = val
    return pdf


def ltlo_cdf(x, phi, sigma, tau):
    x = np.asarray(x, float)
    F = np.zeros_like(x)

    valid = x > 0
    if not np.any(valid):
        return F

    xv = x[valid]
    ratio = (tau / (tau + xv)) ** sigma

    term = 1 - (1 - phi) * ratio
    term = np.maximum(term, 1e-12)

    Fv = 1 - np.log(term) / np.log(phi)
    Fv = np.clip(Fv, 0, 1)

    F[valid] = Fv
    return F


def ltlo_quantile(u, phi, sigma, tau):
    u = np.asarray(u, float)
    u = np.clip(u, 1e-12, 1 - 1e-12)

    num = (1 - phi) * (tau ** sigma)
    denom = 1 - phi ** (1 - u)

    denom = np.where(np.abs(denom) < 1e-12, np.sign(denom) * 1e-12, denom)

    base = num / denom
    base = np.maximum(base, 1e-12)

    return base ** (1 / sigma) - tau


def ltlo_rvs(n, phi, sigma, tau, rng):
    u = rng.uniform(size=n)
    return ltlo_quantile(u, phi, sigma, tau)

def starting_values(x):
    """
    MUCH better starting values than using true parameters.
    Ensures estimator stays near the true region, avoids φ drift.
    """
    xm = np.min(x)
    xb = np.mean(x)
    s2 = np.var(x)

    # tau start
    tau0 = max(0.1, xm)

    # sigma start (based on Lomax MoM)
    num = 2 * (xb - xm)**2
    den = s2 - (xb - xm)**2
    sigma0 = num/den if den > 0 else 1.0
    sigma0 = np.clip(sigma0, 0.2, 3)

    # phi start near 1–3
    phi0 = 1 + xb / xm
    phi0 = np.clip(phi0, 1.001, 3)

    return np.array([phi0, sigma0, tau0])


bounds = [
    (1.0001, 3.5),   # phi (upper bound tightened)
    (0.05,   5.0),   # sigma
    (0.05,   5.0)    # tau
]

def neg_loglik(theta, x):
    phi, sigma, tau = theta
    fx = ltlo_pdf(x, phi, sigma, tau)

    if np.any(fx <= 0):
        return 1e20

    # prevent φ drifting to 3–4–5
    penalty = 2 * (phi - 1.5)**2

    return -np.sum(np.log(fx)) + penalty


def neg_mps(theta, x):
    phi, sigma, tau = theta
    xs = np.sort(x)
    F = ltlo_cdf(xs, phi, sigma, tau)

    if not np.isfinite(F).all():
        return 1e20

    n = len(xs)
    D = np.zeros(n + 1)
    D[0] = F[0]
    D[1:n] = F[1:] - F[:-1]
    D[n] = 1 - F[-1]

    if np.any(D <= 0):
        return 1e20

    penalty = 2 * (phi - 1.5)**2

    return -np.sum(np.log(D)) + penalty

def fit_mle(x, start):
    res = minimize(
        neg_loglik, start, args=(x,),
        method="L-BFGS-B", bounds=bounds
    )
    return res.x


def fit_mps(x, start):
    res = minimize(
        neg_mps, start, args=(x,),
        method="L-BFGS-B", bounds=bounds
    )
    return res.x

def run_simulation(param_list, n_list, R=1000, seed=123):
    rng = np.random.default_rng(seed)
    rows = []

    for phi0, sigma0, tau0 in param_list:
        true = np.array([phi0, sigma0, tau0])

        for n in n_list:
            mle_est = np.zeros((R, 3))
            mps_est = np.zeros((R, 3))

            for i in range(R):
                x = ltlo_rvs(n, phi0, sigma0, tau0, rng)
                start = starting_values(x)

                mle_est[i] = fit_mle(x, start)
                mps_est[i] = fit_mps(x, start)

            mle_mean = mle_est.mean(0)
            mps_mean = mps_est.mean(0)

            mle_mse = ((mle_est - true)**2).mean(0)
            mps_mse = ((mps_est - true)**2).mean(0)

            rows.append({
                "method": "MLE",
                "n": n,
                "phi_true": phi0, "sigma_true": sigma0, "tau_true": tau0,
                "phi_mean": mle_mean[0], "sigma_mean": mle_mean[1], "tau_mean": mle_mean[2],
                "phi_mse": mle_mse[0], "sigma_mse": mle_mse[1], "tau_mse": mle_mse[2]
            })

            rows.append({
                "method": "MPS",
                "n": n,
                "phi_true": phi0, "sigma_true": sigma0, "tau_true": tau0,
                "phi_mean": mps_mean[0], "sigma_mean": mps_mean[1], "tau_mean": mps_mean[2],
                "phi_mse": mps_mse[0], "sigma_mse": mps_mse[1], "tau_mse": mps_mse[2]
            })

    return pd.DataFrame(rows)

if __name__ == "__main__":

    params = [
        (2, 2, 2),
        (1.5, 0.5, 0.8),
        (2.5, 1.5, 1)
    ]

    sample_sizes = [20, 50, 100, 150, 200, 250]

    df = run_simulation(params, sample_sizes, R=1000)

    print(df)
    file_path = "/Users/purvi/Desktop/my_dataframe.csv"

    # Save DataFrame to CSV
    df.to_csv(file_path, index=False)

    print(f"DataFrame saved to {file_path}")
